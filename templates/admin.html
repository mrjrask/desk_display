<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Playlist Scheduler Admin</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0f172a;
      color: #e2e8f0;
    }
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      background: radial-gradient(circle at top, rgba(59,130,246,0.15), transparent 55%), #0f172a;
    }
    header {
      padding: 1.5rem 2rem 1rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 1rem;
    }
    header h1 {
      margin: 0;
      font-size: 1.75rem;
      letter-spacing: -0.02em;
    }
    header .badge {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.3rem 0.75rem;
      border-radius: 999px;
      font-size: 0.8rem;
      background: rgba(59,130,246,0.15);
      border: 1px solid rgba(96,165,250,0.35);
      color: #bfdbfe;
    }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      padding: 0.75rem 2rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.1);
      background: rgba(15, 23, 42, 0.65);
      backdrop-filter: blur(12px);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    button, select, input, textarea {
      font: inherit;
    }
    button {
      padding: 0.55rem 1rem;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: linear-gradient(135deg, #2563eb, #4f46e5);
      color: white;
      font-weight: 600;
      transition: transform 0.15s ease, box-shadow 0.2s ease;
      box-shadow: 0 10px 20px rgba(59,130,246,0.25);
    }
    button.secondary {
      background: rgba(148, 163, 184, 0.12);
      box-shadow: none;
      color: #e2e8f0;
      border: 1px solid rgba(148, 163, 184, 0.25);
    }
    button.danger {
      background: linear-gradient(135deg, #dc2626, #b91c1c);
      box-shadow: 0 10px 20px rgba(239,68,68,0.25);
    }
    button[disabled] {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none !important;
      box-shadow: none;
    }
    button:hover:not([disabled]) {
      transform: translateY(-1px);
      box-shadow: 0 14px 30px rgba(79,70,229,0.35);
    }
    button.secondary:hover:not([disabled]) {
      box-shadow: none;
      border-color: rgba(148, 163, 184, 0.45);
    }
    main {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(320px, 420px) minmax(360px, 1fr) minmax(260px, 320px);
      gap: 1.25rem;
      padding: 1.5rem 2rem 4.5rem;
    }
    section {
      background: rgba(15, 23, 42, 0.78);
      border: 1px solid rgba(148, 163, 184, 0.18);
      border-radius: 18px;
      padding: 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      box-shadow: 0 20px 35px rgba(15, 23, 42, 0.45);
    }
    section h2 {
      margin: 0;
      font-size: 1.1rem;
      letter-spacing: -0.01em;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    #sequence-list, .steps-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .sequence-item, .step-item {
      display: grid;
      grid-template-columns: 32px 1fr auto;
      gap: 0.75rem;
      align-items: center;
      padding: 0.75rem 0.9rem;
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.22);
      background: rgba(30, 41, 59, 0.7);
      transition: border-color 0.15s ease, transform 0.15s ease;
    }
    .sequence-item.dragging {
      opacity: 0.6;
      transform: scale(0.99);
    }
    .drag-handle {
      cursor: grab;
      user-select: none;
      font-size: 1.4rem;
      color: rgba(148, 163, 184, 0.8);
      text-align: center;
    }
    .item-body {
      display: grid;
      gap: 0.35rem;
    }
    .item-title {
      font-weight: 600;
      font-size: 0.95rem;
    }
    .item-meta {
      font-size: 0.78rem;
      color: rgba(148, 163, 184, 0.85);
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .item-actions {
      display: flex;
      gap: 0.4rem;
    }
    .item-actions button {
      padding: 0.3rem 0.6rem;
      font-size: 0.75rem;
    }
    .playlist-card {
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.18);
      background: rgba(30, 41, 59, 0.6);
      padding: 1rem;
      display: grid;
      gap: 0.9rem;
    }
    .playlist-header {
      display: flex;
      justify-content: space-between;
      align-items: start;
      gap: 0.75rem;
    }
    .playlist-title {
      display: grid;
      gap: 0.25rem;
    }
    .playlist-title input {
      background: rgba(15, 23, 42, 0.65);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 10px;
      padding: 0.4rem 0.6rem;
      color: inherit;
      font-size: 0.95rem;
    }
    .badge-small {
      background: rgba(59, 130, 246, 0.18);
      border: 1px solid rgba(96, 165, 250, 0.35);
      color: #bfdbfe;
      font-size: 0.7rem;
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      display: inline-flex;
      gap: 0.25rem;
      align-items: center;
    }
    .step-controls {
      display: flex;
      gap: 0.35rem;
    }
    .step-controls button {
      padding: 0.3rem 0.45rem;
      font-size: 0.7rem;
    }
    .sidebar-list {
      display: grid;
      gap: 0.65rem;
    }
    .sidebar-card {
      padding: 0.75rem;
      border-radius: 12px;
      background: rgba(30, 41, 59, 0.65);
      border: 1px solid rgba(148, 163, 184, 0.18);
      display: grid;
      gap: 0.45rem;
      font-size: 0.85rem;
    }
    textarea {
      width: 100%;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.75);
      border: 1px solid rgba(148, 163, 184, 0.25);
      color: inherit;
      padding: 0.6rem;
      min-height: 120px;
    }
    .status-bar {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 0.75rem 2rem;
      background: rgba(15, 23, 42, 0.95);
      border-top: 1px solid rgba(148, 163, 184, 0.2);
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 0.75rem;
      font-size: 0.9rem;
    }
    .status-bar .error {
      color: #fca5a5;
    }
    #preview-drawer {
      position: fixed;
      right: 1.5rem;
      bottom: 5rem;
      width: min(420px, calc(100% - 3rem));
      max-height: 60vh;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 18px;
      padding: 1rem 1.25rem;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.6);
      display: none;
      flex-direction: column;
      gap: 0.6rem;
    }
    #preview-drawer.open {
      display: flex;
    }
    #preview-list {
      list-style: none;
      margin: 0;
      padding: 0;
      max-height: 45vh;
      overflow: auto;
      display: grid;
      gap: 0.35rem;
      font-size: 0.85rem;
    }
    #preview-list li {
      padding: 0.35rem 0.55rem;
      border-radius: 10px;
      background: rgba(30, 41, 59, 0.65);
      border: 1px solid rgba(148, 163, 184, 0.18);
    }
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.65);
      backdrop-filter: blur(8px);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      z-index: 50;
    }
    .modal-backdrop.open {
      display: flex;
    }
    .modal {
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 18px;
      padding: 1.5rem;
      width: min(520px, 100%);
      display: grid;
      gap: 1rem;
      max-height: 80vh;
      overflow: auto;
    }
    .modal h3 {
      margin: 0;
      font-size: 1.2rem;
    }
    .modal label {
      font-size: 0.85rem;
      font-weight: 600;
      display: block;
      margin-bottom: 0.35rem;
    }
    .modal input, .modal select {
      width: 100%;
      padding: 0.5rem 0.6rem;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(15, 23, 42, 0.75);
      color: inherit;
    }
    .wizard-list {
      display: grid;
      gap: 0.5rem;
    }
    .wizard-row {
      display: grid;
      grid-template-columns: 1fr 1fr auto;
      gap: 0.5rem;
      align-items: center;
    }
    .wizard-row button {
      padding: 0.35rem 0.45rem;
      font-size: 0.75rem;
    }
    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }
    .day-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 0.45rem;
    }
    .day-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      border-radius: 999px;
      padding: 0.3rem 0.65rem;
      border: 1px solid rgba(148, 163, 184, 0.25);
      cursor: pointer;
      background: rgba(30, 41, 59, 0.75);
      transition: background 0.15s ease, border-color 0.15s ease;
    }
    .form-hint {
      font-size: 0.8rem;
      color: rgba(148, 163, 184, 0.75);
      background: rgba(30, 41, 59, 0.6);
      border: 1px dashed rgba(148, 163, 184, 0.25);
      padding: 0.5rem 0.75rem;
      border-radius: 12px;
    }
    .screen-picker {
      display: grid;
      gap: 0.5rem;
    }
    .screen-picker input[type="search"] {
      width: 100%;
      padding: 0.5rem 0.6rem;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(15, 23, 42, 0.75);
      color: inherit;
    }
    .screen-picker-list {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      max-height: 220px;
      overflow-y: auto;
      padding: 0.35rem;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.18);
      background: rgba(15, 23, 42, 0.5);
    }
    .screen-picker-empty {
      font-size: 0.8rem;
      color: rgba(148, 163, 184, 0.7);
      padding: 0.25rem 0.4rem;
    }
    .screen-picker-hint {
      font-size: 0.78rem;
      color: rgba(148, 163, 184, 0.75);
    }
    .screen-chip {
      padding: 0.35rem 0.6rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(30, 41, 59, 0.65);
      color: inherit;
      cursor: pointer;
      font-size: 0.78rem;
      transition: border-color 0.15s ease, background 0.15s ease;
    }
    .screen-chip:hover {
      border-color: rgba(148, 163, 184, 0.5);
      background: rgba(59, 130, 246, 0.15);
    }
    .screen-chip.selected {
      border-color: rgba(96, 165, 250, 0.6);
      background: rgba(59, 130, 246, 0.22);
    }
    .frequency-control {
      display: grid;
      gap: 0.5rem;
    }
    .frequency-control input[type="number"] {
      width: 160px;
      padding: 0.5rem 0.6rem;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(15, 23, 42, 0.75);
      color: inherit;
    }
    .frequency-control input[type="range"] {
      width: 100%;
    }
    .frequency-readout {
      font-size: 0.85rem;
      color: rgba(148, 163, 184, 0.85);
    }
    .frequency-quick-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }
    .chip-button {
      padding: 0.35rem 0.6rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(30, 41, 59, 0.6);
      color: inherit;
      cursor: pointer;
      font-size: 0.78rem;
      transition: border-color 0.15s ease, background 0.15s ease, transform 0.15s ease;
    }
    .chip-button:hover {
      border-color: rgba(96, 165, 250, 0.5);
      background: rgba(59, 130, 246, 0.15);
      transform: translateY(-1px);
    }
    .day-chip input {
      pointer-events: none;
    }
    .day-chip.selected {
      background: rgba(59, 130, 246, 0.22);
      border-color: rgba(96, 165, 250, 0.45);
    }
    @media (max-width: 1100px) {
      main {
        grid-template-columns: 1fr;
      }
    }
    @media (max-width: 640px) {
      header, .toolbar {
        padding: 1rem;
      }
      main {
        padding: 1.25rem 1rem 4.5rem;
      }
      section {
        padding: 1rem;
      }
      .sequence-item, .step-item {
        grid-template-columns: 1fr;
      }
      .drag-handle {
        display: none;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Playlist Scheduler</h1>
    <div class="badge" id="migration-badge"></div>
  </header>

  <div class="toolbar">
    <button type="button" id="save-button">Save changes</button>
    <button type="button" class="secondary" id="preview-button">Simulate next 20 screens</button>
    <button type="button" class="secondary" id="new-playlist">New playlist</button>
    <button type="button" class="secondary" id="add-sequence-playlist">Insert playlist into sequence</button>
    <button type="button" class="secondary" id="add-sequence-screen">Insert screen into sequence</button>
    <div style="flex:1"></div>
    <input id="actor-input" type="text" placeholder="Actor (optional)" style="max-width:180px;padding:0.45rem 0.7rem;border-radius:999px;border:1px solid rgba(148,163,184,0.25);background:rgba(15,23,42,0.65);color:inherit;">
    <input id="summary-input" type="text" placeholder="Summary" style="max-width:220px;padding:0.45rem 0.7rem;border-radius:999px;border:1px solid rgba(148,163,184,0.25);background:rgba(15,23,42,0.65);color:inherit;">
  </div>

  <main>
    <section id="sequence-panel">
      <h2><span>Active sequence</span><span id="sequence-count"></span></h2>
      <ul id="sequence-list" aria-live="polite"></ul>
      <div class="sidebar-card" id="sequence-help">
        Drag items to reorder playback. Sequence entries can reference playlists, individual screens, or rules created via the wizards inside each playlist.
      </div>
    </section>

    <section id="playlists-panel">
      <h2>Playlists</h2>
      <div id="playlists-container" class="sidebar-list"></div>
    </section>

    <section id="history-panel">
      <h2>Version history</h2>
      <div class="sidebar-card">
        <p style="margin:0;font-size:0.85rem;color:rgba(148,163,184,0.9);">Restore any previous save. Versions beyond the retention window are pruned automatically.</p>
      </div>
      <div id="history-container" class="sidebar-list"></div>
      <div class="sidebar-card" id="preset-card">
        <h3 style="margin:0;font-size:0.95rem;">Preset blocks</h3>
        <div id="preset-container" class="sidebar-list"></div>
      </div>
    </section>
  </main>

  <div class="status-bar">
    <div id="status-text">Ready.</div>
    <div id="validation-text"></div>
  </div>

  <div id="preview-drawer">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <strong>Preview</strong>
      <button type="button" class="secondary" id="close-preview">Close</button>
    </div>
    <ul id="preview-list"></ul>
  </div>

  <div id="modal-backdrop" class="modal-backdrop">
    <div class="modal" role="dialog" aria-modal="true">
      <h3 id="modal-title"></h3>
      <div id="modal-content"></div>
      <div style="display:flex;justify-content:flex-end;gap:0.5rem;">
        <button type="button" class="secondary" id="modal-cancel">Cancel</button>
        <button type="button" id="modal-confirm">Apply</button>
      </div>
    </div>
  </div>

  <script id="bootstrap-data" type="application/json">{{ bootstrap | tojson }}</script>
  <script>
    const bootstrapEl = document.getElementById('bootstrap-data');
    window.BOOTSTRAP = JSON.parse(bootstrapEl.textContent);
  </script>
  <script>
    const supportsStructuredClone = typeof structuredClone === 'function';
    const state = {
      config: supportsStructuredClone
        ? structuredClone(window.BOOTSTRAP.config)
        : JSON.parse(JSON.stringify(window.BOOTSTRAP.config)),
      screens: window.BOOTSTRAP.screens || [],
      validation: window.BOOTSTRAP.validation || [],
      migrated: Boolean(window.BOOTSTRAP.migrated),
      versions: window.BOOTSTRAP.versions || [],
      latestVersionId: window.BOOTSTRAP.latest_version_id || null,
      dirty: false,
      saving: false,
      preview: [],
      previewOpen: false,
      statusMessage: null,
    };

    const sequenceListEl = document.getElementById('sequence-list');
    const playlistsContainer = document.getElementById('playlists-container');
    const historyContainer = document.getElementById('history-container');
    const presetContainer = document.getElementById('preset-container');
    const statusText = document.getElementById('status-text');
    const validationText = document.getElementById('validation-text');
    const sequenceCount = document.getElementById('sequence-count');
    const migrationBadge = document.getElementById('migration-badge');
    const previewDrawer = document.getElementById('preview-drawer');
    const previewList = document.getElementById('preview-list');
    const modalBackdrop = document.getElementById('modal-backdrop');
    const modalTitle = document.getElementById('modal-title');
    const modalContent = document.getElementById('modal-content');
    const modalConfirm = document.getElementById('modal-confirm');
    const modalCancel = document.getElementById('modal-cancel');
    const actorInput = document.getElementById('actor-input');
    const summaryInput = document.getElementById('summary-input');

    let dragIndex = null;
    let modalHandler = null;

    function markDirty() {
      state.dirty = true;
      state.statusMessage = null;
      renderStatus();
    }

    function clone(value) {
      try {
        return structuredClone(value);
      } catch (err) {
        return JSON.parse(JSON.stringify(value));
      }
    }

    function ensureSequenceNotEmpty() {
      if (!Array.isArray(state.config.sequence) || state.config.sequence.length === 0) {
        state.config.sequence = [{ playlist: Object.keys(state.config.playlists)[0] || 'main' }];
      }
    }

    function summariseStep(step) {
      if (typeof step === 'string') {
        return { title: `Screen · ${step}`, meta: [] };
      }
      if (!step || typeof step !== 'object') {
        return { title: 'Unknown entry', meta: [] };
      }
      if (step.playlist) {
        const pl = state.config.playlists[step.playlist];
        const label = pl?.label ? `${pl.label} (${step.playlist})` : step.playlist;
        return { title: `Playlist · ${label}`, meta: describeConditions(step.conditions) };
      }
      if (step.screen) {
        return { title: `Screen · ${step.screen}`, meta: describeConditions(step.conditions) };
      }
      if (step.rule) {
        const rule = step.rule;
        if (rule.type === 'variants') {
          return { title: 'Rule · Variants', meta: [`Options: ${(rule.options || []).join(', ')}`].concat(describeConditions(step.conditions)) };
        }
        if (rule.type === 'cycle') {
          return { title: 'Rule · Cycle', meta: [`Items: ${summariseInline(rule.items || rule.cycle || [])}`].concat(describeConditions(step.conditions)) };
        }
        if (rule.type === 'every') {
          return { title: 'Rule · Every', meta: [`Every ${rule.frequency || rule.every}`, summariseStep(rule.item || rule.screen).title].concat(describeConditions(step.conditions)) };
        }
        return { title: `Rule · ${rule.type || 'custom'}`, meta: describeConditions(step.conditions) };
      }
      if (step.steps) {
        return { title: 'Inline playlist', meta: [`Steps: ${step.steps.length}`].concat(describeConditions(step.conditions)) };
      }
      return { title: 'Entry', meta: describeConditions(step.conditions) };
    }

    function summariseInline(items) {
      return items.map(item => {
        const info = summariseStep(item);
        return info.title.replace('Screen · ', '').replace('Playlist · ', '');
      }).join(', ');
    }

    function describeConditions(conditions) {
      if (!conditions || typeof conditions !== 'object') return [];
      const meta = [];
      if (conditions.days_of_week || conditions.day_of_week) {
        const days = conditions.days_of_week || conditions.day_of_week || [];
        const list = Array.isArray(days) ? days : [days];
        meta.push(`Days: ${list.join(', ')}`);
      }
      const ranges = conditions.time_of_day || conditions.time_ranges;
      if (Array.isArray(ranges) && ranges.length) {
        meta.push(`Time: ${ranges.map(r => `${r.start}–${r.end}`).join('; ')}`);
      }
      return meta;
    }

    function renderSequence() {
      sequenceListEl.innerHTML = '';
      state.config.sequence.forEach((step, index) => {
        const li = document.createElement('li');
        li.className = 'sequence-item';
        li.draggable = true;
        li.dataset.index = index;

        li.addEventListener('dragstart', (event) => {
          dragIndex = index;
          li.classList.add('dragging');
          event.dataTransfer.effectAllowed = 'move';
        });
        li.addEventListener('dragend', () => {
          dragIndex = null;
          li.classList.remove('dragging');
        });
        li.addEventListener('dragover', (event) => {
          event.preventDefault();
          const targetIndex = Number(li.dataset.index);
          if (dragIndex === targetIndex) return;
          if (dragIndex === null) return;
          const item = state.config.sequence.splice(dragIndex, 1)[0];
          state.config.sequence.splice(targetIndex, 0, item);
          dragIndex = targetIndex;
          renderSequence();
          markDirty();
        });

        const handle = document.createElement('div');
        handle.className = 'drag-handle';
        handle.textContent = '⋮⋮';

        const body = document.createElement('div');
        body.className = 'item-body';
        const summary = summariseStep(step);
        const title = document.createElement('div');
        title.className = 'item-title';
        title.textContent = summary.title;
        body.appendChild(title);
        if (summary.meta.length) {
          const meta = document.createElement('div');
          meta.className = 'item-meta';
          summary.meta.forEach(text => {
            const span = document.createElement('span');
            span.className = 'badge-small';
            span.textContent = text;
            meta.appendChild(span);
          });
          body.appendChild(meta);
        }

        const actions = document.createElement('div');
        actions.className = 'item-actions';

        const editButton = document.createElement('button');
        editButton.type = 'button';
        editButton.className = 'secondary';
        editButton.textContent = 'Edit';
        editButton.addEventListener('click', () => openSequenceEditor(index));

        const removeButton = document.createElement('button');
        removeButton.type = 'button';
        removeButton.className = 'secondary';
        removeButton.textContent = 'Remove';
        removeButton.addEventListener('click', () => {
          state.config.sequence.splice(index, 1);
          ensureSequenceNotEmpty();
          renderAll();
          markDirty();
        });

        actions.appendChild(editButton);
        actions.appendChild(removeButton);

        li.appendChild(handle);
        li.appendChild(body);
        li.appendChild(actions);
        sequenceListEl.appendChild(li);
      });

      sequenceCount.textContent = `${state.config.sequence.length} entries`;
    }

    function renderPlaylists() {
      playlistsContainer.innerHTML = '';
      const ids = Object.keys(state.config.playlists);
      ids.sort();
      ids.forEach((playlistId) => {
        const playlist = state.config.playlists[playlistId];
        const card = document.createElement('div');
        card.className = 'playlist-card';

        const header = document.createElement('div');
        header.className = 'playlist-header';
        const title = document.createElement('div');
        title.className = 'playlist-title';

        const labelInput = document.createElement('input');
        labelInput.type = 'text';
        labelInput.value = playlist.label || '';
        labelInput.placeholder = `Playlist ${playlistId}`;
        labelInput.addEventListener('change', () => {
          playlist.label = labelInput.value.trim();
          markDirty();
        });

        const idTag = document.createElement('span');
        idTag.className = 'badge-small';
        idTag.textContent = playlistId;

        title.appendChild(labelInput);
        title.appendChild(idTag);

        const headerButtons = document.createElement('div');
        headerButtons.className = 'item-actions';

        const addScreen = document.createElement('button');
        addScreen.type = 'button';
        addScreen.className = 'secondary';
        addScreen.textContent = 'Add screen';
        addScreen.addEventListener('click', () => openStepWizard(playlistId, 'screen'));

        const addPlaylist = document.createElement('button');
        addPlaylist.type = 'button';
        addPlaylist.className = 'secondary';
        addPlaylist.textContent = 'Add playlist';
        addPlaylist.addEventListener('click', () => openStepWizard(playlistId, 'playlist'));

        const addRule = document.createElement('button');
        addRule.type = 'button';
        addRule.className = 'secondary';
        addRule.textContent = 'Rule wizard';
        addRule.addEventListener('click', () => openRuleWizard(playlistId));

        const conditionBtn = document.createElement('button');
        conditionBtn.type = 'button';
        conditionBtn.className = 'secondary';
        conditionBtn.textContent = 'Conditions';
        conditionBtn.addEventListener('click', () => openConditionEditor(playlistId));

        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.className = 'danger';
        deleteBtn.textContent = 'Delete';
        deleteBtn.addEventListener('click', () => removePlaylist(playlistId));

        headerButtons.appendChild(addScreen);
        headerButtons.appendChild(addPlaylist);
        headerButtons.appendChild(addRule);
        headerButtons.appendChild(conditionBtn);
        if (ids.length > 1) headerButtons.appendChild(deleteBtn);

        header.appendChild(title);
        header.appendChild(headerButtons);
        card.appendChild(header);

        if (playlist.conditions) {
          const conditionRow = document.createElement('div');
          conditionRow.className = 'item-meta';
          describeConditions(playlist.conditions).forEach(text => {
            const span = document.createElement('span');
            span.className = 'badge-small';
            span.textContent = text;
            conditionRow.appendChild(span);
          });
          if (conditionRow.children.length) {
            card.appendChild(conditionRow);
          }
        }

        const list = document.createElement('ul');
        list.className = 'steps-list';
        (playlist.steps || []).forEach((step, index) => {
          const item = document.createElement('li');
          item.className = 'step-item';
          const summary = summariseStep(step);

          const icon = document.createElement('div');
          icon.className = 'drag-handle';
          icon.textContent = index + 1;

          const body = document.createElement('div');
          body.className = 'item-body';
          const titleRow = document.createElement('div');
          titleRow.className = 'item-title';
          titleRow.textContent = summary.title;
          body.appendChild(titleRow);
          if (summary.meta.length) {
            const meta = document.createElement('div');
            meta.className = 'item-meta';
            summary.meta.forEach(text => {
              const span = document.createElement('span');
              span.className = 'badge-small';
              span.textContent = text;
              meta.appendChild(span);
            });
            body.appendChild(meta);
          }

          const controls = document.createElement('div');
          controls.className = 'step-controls';

          const upBtn = document.createElement('button');
          upBtn.type = 'button';
          upBtn.className = 'secondary';
          upBtn.textContent = '↑';
          upBtn.disabled = index === 0;
          upBtn.addEventListener('click', () => {
            if (index === 0) return;
            const steps = playlist.steps;
            [steps[index - 1], steps[index]] = [steps[index], steps[index - 1]];
            renderPlaylists();
            markDirty();
          });

          const downBtn = document.createElement('button');
          downBtn.type = 'button';
          downBtn.className = 'secondary';
          downBtn.textContent = '↓';
          downBtn.disabled = index === playlist.steps.length - 1;
          downBtn.addEventListener('click', () => {
            if (index === playlist.steps.length - 1) return;
            const steps = playlist.steps;
            [steps[index + 1], steps[index]] = [steps[index], steps[index + 1]];
            renderPlaylists();
            markDirty();
          });

          const editBtn = document.createElement('button');
          editBtn.type = 'button';
          editBtn.className = 'secondary';
          editBtn.textContent = 'Edit';
          editBtn.addEventListener('click', () => openStepEditor(playlistId, index));

          const removeBtn = document.createElement('button');
          removeBtn.type = 'button';
          removeBtn.className = 'secondary';
          removeBtn.textContent = '✕';
          removeBtn.addEventListener('click', () => {
            playlist.steps.splice(index, 1);
            renderPlaylists();
            markDirty();
          });

          controls.appendChild(upBtn);
          controls.appendChild(downBtn);
          controls.appendChild(editBtn);
          controls.appendChild(removeBtn);

          item.appendChild(icon);
          item.appendChild(body);
          item.appendChild(controls);
          list.appendChild(item);
        });

        card.appendChild(list);
        playlistsContainer.appendChild(card);
      });
    }

    function renderHistory() {
      historyContainer.innerHTML = '';
      if (!state.versions || !state.versions.length) {
        const empty = document.createElement('div');
        empty.className = 'sidebar-card';
        empty.textContent = 'No saved versions yet.';
        historyContainer.appendChild(empty);
        return;
      }
      state.versions.forEach(entry => {
        const card = document.createElement('div');
        card.className = 'sidebar-card';
        const title = document.createElement('div');
        title.style.fontWeight = '600';
        title.textContent = `#${entry.id} · ${entry.created_at}`;
        const meta = document.createElement('div');
        meta.style.fontSize = '0.8rem';
        meta.style.color = 'rgba(148,163,184,0.85)';
        meta.textContent = `${entry.actor} — ${entry.summary}`;
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'secondary';
        button.textContent = 'Restore';
        button.addEventListener('click', () => rollbackVersion(entry.id));
        card.appendChild(title);
        card.appendChild(meta);
        card.appendChild(button);
        historyContainer.appendChild(card);
      });
    }

    function renderPresets() {
      presetContainer.innerHTML = '';
      const catalog = state.config.catalog || {};
      const presets = catalog.presets || {};
      const entries = Object.entries(presets);
      if (!entries.length) {
        const empty = document.createElement('div');
        empty.textContent = 'No presets defined. Add presets in catalog → presets in the config file.';
        presetContainer.appendChild(empty);
        return;
      }
      entries.forEach(([presetId, descriptor]) => {
        const card = document.createElement('div');
        card.className = 'sidebar-card';
        card.style.gap = '0.35rem';
        const title = document.createElement('div');
        title.style.fontWeight = '600';
        title.textContent = presetId;
        const desc = document.createElement('div');
        desc.style.fontSize = '0.8rem';
        desc.style.color = 'rgba(148,163,184,0.85)';
        desc.textContent = summariseStep(descriptor).title;
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'secondary';
        button.textContent = 'Insert into sequence';
        button.addEventListener('click', () => {
          state.config.sequence.push(clone(descriptor));
          ensureSequenceNotEmpty();
          renderAll();
          markDirty();
        });
        card.appendChild(title);
        card.appendChild(desc);
        card.appendChild(button);
        presetContainer.appendChild(card);
      });
    }

    function renderStatus() {
      if (state.statusMessage) {
        statusText.textContent = state.statusMessage.text;
        statusText.classList.toggle('error', Boolean(state.statusMessage.error));
      } else {
        statusText.classList.remove('error');
        const parts = [];
        if (state.dirty) parts.push('Unsaved changes');
        if (state.saving) parts.push('Saving…');
        if (!parts.length) parts.push('Ready.');
        statusText.textContent = parts.join(' · ');
      }

      if (state.validation && state.validation.length) {
        validationText.textContent = `Validation: ${state.validation.join(' | ')}`;
        validationText.className = 'error';
      } else {
        validationText.textContent = '';
        validationText.className = '';
      }

      migrationBadge.textContent = state.migrated ? 'Migrated to schema v2' : 'Schema v2';
    }

    function renderPreview() {
      previewList.innerHTML = '';
      state.preview.forEach((screenId, idx) => {
        const li = document.createElement('li');
        li.textContent = `${idx + 1}. ${screenId}`;
        previewList.appendChild(li);
      });
      previewDrawer.classList.toggle('open', state.previewOpen);
    }

    function renderAll() {
      ensureSequenceNotEmpty();
      renderSequence();
      renderPlaylists();
      renderHistory();
      renderPresets();
      renderStatus();
      renderPreview();
    }

    function removePlaylist(playlistId) {
      if (!confirm(`Delete playlist ${playlistId}? Entries referencing it will also be removed.`)) {
        return;
      }
      delete state.config.playlists[playlistId];
      state.config.sequence = state.config.sequence.filter(entry => !(entry && typeof entry === 'object' && entry.playlist === playlistId));
      Object.values(state.config.playlists).forEach(pl => {
        pl.steps = (pl.steps || []).filter(step => !(step && step.playlist === playlistId));
      });
      ensureSequenceNotEmpty();
      renderAll();
      markDirty();
    }

    function openModal(title, contentBuilder, onConfirm) {
      modalTitle.textContent = title;
      modalContent.innerHTML = '';
      modalHandler = typeof onConfirm === 'function' ? onConfirm : null;
      contentBuilder(modalContent);
      modalBackdrop.classList.add('open');
    }

    modalConfirm.addEventListener('click', () => {
      if (typeof modalHandler === 'function') {
        const result = modalHandler();
        if (result === false) {
          return;
        }
      }
      modalBackdrop.classList.remove('open');
      modalHandler = null;
    });

    modalCancel.addEventListener('click', () => {
      modalBackdrop.classList.remove('open');
      modalHandler = null;
    });

    function createOptionSelect(options, value) {
      const select = document.createElement('select');
      options.forEach(opt => {
        const option = document.createElement('option');
        option.value = opt.value;
        option.textContent = opt.label;
        if (opt.value === value) option.selected = true;
        select.appendChild(option);
      });
      return select;
    }

    function normaliseScreenId(value) {
      if (!value) return null;
      const lookup = value.trim().toLowerCase();
      return state.screens.find(id => id.toLowerCase() === lookup) || null;
    }

    function createFormHint(text) {
      const hint = document.createElement('div');
      hint.className = 'form-hint';
      hint.textContent = text;
      return hint;
    }

    function createScreenPicker(initialValue) {
      const wrapper = document.createElement('div');
      wrapper.className = 'screen-picker';

      const input = document.createElement('input');
      input.type = 'search';
      input.placeholder = 'Search or type a screen name…';

      const hint = document.createElement('div');
      hint.className = 'screen-picker-hint';

      const list = document.createElement('div');
      list.className = 'screen-picker-list';

      const initial = normaliseScreenId(initialValue) || (state.screens[0] || '');
      let selection = initial;
      if (initial) {
        input.value = initial;
      }

      function updateHint() {
        if (!state.screens.length) {
          hint.textContent = 'No screens available in the catalog yet.';
          return;
        }
        const value = input.value.trim();
        if (!value) {
          hint.textContent = 'Click a screen name below or start typing to filter the list.';
          return;
        }
        const match = normaliseScreenId(value);
        if (match) {
          hint.textContent = `Using screen “${match}”.`;
        } else {
          hint.textContent = `No exact match for “${value}”. Click a name below to fill it.`;
        }
      }

      function renderList() {
        const typed = input.value.trim().toLowerCase();
        list.innerHTML = '';
        if (!state.screens.length) {
          const empty = document.createElement('div');
          empty.className = 'screen-picker-empty';
          empty.textContent = 'Add screens in the catalog to see them here.';
          list.appendChild(empty);
          return;
        }
        const matches = state.screens.filter(id => !typed || id.toLowerCase().includes(typed));
        if (!matches.length) {
          const empty = document.createElement('div');
          empty.className = 'screen-picker-empty';
          empty.textContent = 'No matches. Try a different search.';
          list.appendChild(empty);
          return;
        }
        matches.forEach(id => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'screen-chip';
          const active = input.value ? id.toLowerCase() === typed : selection === id;
          if (active) button.classList.add('selected');
          button.textContent = id;
          button.addEventListener('click', () => {
            selection = id;
            input.value = id;
            renderList();
            updateHint();
          });
          list.appendChild(button);
        });
      }

      input.addEventListener('input', () => {
        renderList();
        updateHint();
      });

      wrapper.appendChild(input);
      wrapper.appendChild(list);
      wrapper.appendChild(hint);
      renderList();
      if (!input.value && selection) {
        input.value = selection;
        renderList();
      }
      updateHint();

      return {
        element: wrapper,
        getValue() {
          return input.value.trim() || selection || '';
        },
        setValue(value) {
          const match = normaliseScreenId(value);
          selection = match || value || '';
          input.value = match || value || '';
          renderList();
          updateHint();
        },
      };
    }

    function createFrequencyControl(initialValue) {
      const wrapper = document.createElement('div');
      wrapper.className = 'frequency-control';

      const numberInput = document.createElement('input');
      numberInput.type = 'number';
      numberInput.min = '1';
      numberInput.step = '1';
      numberInput.inputMode = 'numeric';

      const slider = document.createElement('input');
      slider.type = 'range';
      slider.min = '1';
      slider.max = '30';

      const readout = document.createElement('div');
      readout.className = 'frequency-readout';

      const quickRow = document.createElement('div');
      quickRow.className = 'frequency-quick-row';

      function setValue(raw) {
        const parsed = parseInt(raw, 10);
        const safe = Number.isFinite(parsed) && parsed > 0 ? parsed : 1;
        numberInput.value = String(safe);
        slider.value = String(Math.min(safe, Number(slider.max)));
        readout.textContent = `Every ${safe} loop${safe === 1 ? '' : 's'}`;
      }

      numberInput.addEventListener('input', () => {
        setValue(numberInput.value);
      });

      slider.addEventListener('input', () => {
        setValue(slider.value);
      });

      [1, 2, 3, 5, 10, 20].forEach(value => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'chip-button';
        btn.textContent = value;
        btn.addEventListener('click', () => setValue(value));
        quickRow.appendChild(btn);
      });

      setValue(initialValue || 3);

      wrapper.appendChild(readout);
      wrapper.appendChild(numberInput);
      wrapper.appendChild(slider);
      wrapper.appendChild(quickRow);

      return {
        element: wrapper,
        getValue() {
          return parseInt(numberInput.value, 10) || 1;
        },
        setValue,
      };
    }

    function buildDescriptorForm(descriptor) {
      const base = clone(descriptor);

      function detectKind(step) {
        if (typeof step === 'string') {
          return { type: 'screen', representation: 'string', screen: step };
        }
        if (!step || typeof step !== 'object') {
          return null;
        }
        if (typeof step.screen === 'string' && !step.rule && !step.playlist && !step.steps) {
          return {
            type: 'screen',
            representation: 'object',
            screen: step.screen,
            hasConditions: Boolean(step.conditions),
            hasExtras: Object.keys(step).some(key => !['screen', 'conditions'].includes(key)),
          };
        }
        if (typeof step.playlist === 'string' && !step.rule && !step.steps) {
          return {
            type: 'playlist',
            playlist: step.playlist,
            hasExtras: Object.keys(step).some(key => !['playlist', 'conditions'].includes(key)),
            hasConditions: Boolean(step.conditions),
          };
        }
        if (step.rule && step.rule.type === 'every') {
          const rule = step.rule;
          const frequency = Number.isFinite(rule.frequency) ? rule.frequency : Number(rule.every) || 1;
          let screen = null;
          if (rule.item) {
            if (typeof rule.item === 'string') {
              screen = rule.item;
            } else if (typeof rule.item === 'object' && typeof rule.item.screen === 'string') {
              screen = rule.item.screen;
            }
          }
          if (!screen && typeof rule.screen === 'string') {
            screen = rule.screen;
          }
          if (!screen) {
            return null;
          }
          return {
            type: 'rule-every',
            screen,
            frequency: frequency || 1,
            hasExtras: Object.keys(rule).some(key => !['type', 'frequency', 'every', 'item', 'screen'].includes(key)),
            hasConditions: Boolean(step.conditions),
          };
        }
        return null;
      }

      const kind = detectKind(base);
      if (!kind) {
        return null;
      }

      const wrapper = document.createElement('div');
      wrapper.className = 'step-form';

      if (kind.type === 'screen') {
        const label = document.createElement('label');
        label.textContent = 'Screen';
        const picker = createScreenPicker(kind.screen);
        wrapper.appendChild(label);
        wrapper.appendChild(picker.element);
        if (kind.hasConditions) {
          wrapper.appendChild(createFormHint('Existing conditions will be preserved. Use the JSON editor to modify them.'));
        }
        if (kind.hasExtras) {
          wrapper.appendChild(createFormHint('Additional properties are attached to this step and will be kept as-is.'));
        }
        return {
          element: wrapper,
          commit() {
            const selected = normaliseScreenId(picker.getValue());
            if (!selected) {
              return { ok: false, message: 'Select a screen from the list.' };
            }
            if (typeof base === 'string') {
              return { ok: true, step: selected };
            }
            const next = clone(base);
            if (!next || typeof next !== 'object') {
              return { ok: true, step: { screen: selected } };
            }
            next.screen = selected;
            return { ok: true, step: next };
          },
        };
      }

      if (kind.type === 'playlist') {
        const label = document.createElement('label');
        label.textContent = 'Playlist';
        const ids = Object.keys(state.config.playlists || {});
        let select = null;
        if (!ids.length) {
          wrapper.appendChild(createFormHint('No playlists available. Create one before editing this entry.'));
        } else {
          select = createOptionSelect(ids.map(id => ({ value: id, label: id })), kind.playlist);
          wrapper.appendChild(label);
          wrapper.appendChild(select);
        }
        if (kind.hasConditions) {
          wrapper.appendChild(createFormHint('Existing conditions on this entry will be preserved.'));
        }
        if (kind.hasExtras) {
          wrapper.appendChild(createFormHint('Extra properties were detected and will remain unchanged.'));
        }
        return {
          element: wrapper,
          commit() {
            if (!select) {
              return { ok: false, message: 'Create a playlist first.' };
            }
            const selected = select.value;
            if (!selected) {
              return { ok: false, message: 'Choose a playlist.' };
            }
            const next = typeof base === 'object' && base ? clone(base) : {};
            next.playlist = selected;
            return { ok: true, step: next };
          },
        };
      }

      if (kind.type === 'rule-every') {
        const freqLabel = document.createElement('label');
        freqLabel.textContent = 'Loop frequency';
        const freqControl = createFrequencyControl(kind.frequency);
        wrapper.appendChild(freqLabel);
        wrapper.appendChild(freqControl.element);

        const screenLabel = document.createElement('label');
        screenLabel.textContent = 'Screen to show at this frequency';
        const picker = createScreenPicker(kind.screen);
        wrapper.appendChild(screenLabel);
        wrapper.appendChild(picker.element);

        if (kind.hasExtras) {
          wrapper.appendChild(createFormHint('This rule has additional properties that will remain unchanged.'));
        }
        if (kind.hasConditions) {
          wrapper.appendChild(createFormHint('Step-level conditions stay intact. Use the JSON editor to modify them.'));
        }

        return {
          element: wrapper,
          commit() {
            const freq = freqControl.getValue();
            if (!Number.isInteger(freq) || freq <= 0) {
              return { ok: false, message: 'Frequency must be a positive integer.' };
            }
            const screen = normaliseScreenId(picker.getValue());
            if (!screen) {
              return { ok: false, message: 'Select a screen from the list.' };
            }
            const next = typeof base === 'object' && base ? clone(base) : {};
            next.rule = next.rule ? clone(next.rule) : {};
            next.rule.type = 'every';
            next.rule.frequency = freq;
            next.rule.every = freq;
            next.rule.item = { screen };
            if (next.rule.screen) {
              delete next.rule.screen;
            }
            return { ok: true, step: next };
          },
        };
      }

      return null;
    }

    function openDescriptorEditor(title, descriptor, onSave) {
      openModal(title, (container) => {
        function renderSimple(currentValue) {
          const form = buildDescriptorForm(currentValue);
          if (!form) {
            renderAdvanced(currentValue);
            return;
          }
          container.innerHTML = '';
          container.appendChild(form.element);
          const footer = document.createElement('div');
          footer.className = 'modal-footer';
          const advancedBtn = document.createElement('button');
          advancedBtn.type = 'button';
          advancedBtn.className = 'secondary';
          advancedBtn.textContent = 'Open JSON editor';
          advancedBtn.addEventListener('click', () => {
            const result = form.commit();
            if (!result.ok) {
              if (result.message) alert(result.message);
              return;
            }
            renderAdvanced(clone(result.step));
          });
          footer.appendChild(advancedBtn);
          container.appendChild(footer);
          modalHandler = () => {
            const result = form.commit();
            if (!result.ok) {
              if (result.message) alert(result.message);
              return false;
            }
            onSave(result.step);
          };
        }

        function renderAdvanced(currentValue) {
          container.innerHTML = '';
          const textarea = document.createElement('textarea');
          textarea.value = JSON.stringify(currentValue, null, 2);
          textarea.rows = 14;
          container.appendChild(textarea);
          container.appendChild(createFormHint('Edit the raw JSON to access every property.')); 
          const footer = document.createElement('div');
          footer.className = 'modal-footer';
          const formBtn = document.createElement('button');
          formBtn.type = 'button';
          formBtn.className = 'secondary';
          formBtn.textContent = 'Use form editor';
          formBtn.addEventListener('click', () => {
            try {
              const parsed = JSON.parse(textarea.value);
              if (!buildDescriptorForm(parsed)) {
                alert('This entry cannot be represented in the form editor.');
                return;
              }
              renderSimple(clone(parsed));
            } catch (err) {
              alert('Fix the JSON before returning to the form editor: ' + err.message);
            }
          });
          footer.appendChild(formBtn);
          container.appendChild(footer);

          modalHandler = () => {
            try {
              const parsed = JSON.parse(textarea.value);
              onSave(parsed);
            } catch (err) {
              alert('Invalid JSON: ' + err.message);
              return false;
            }
          };
        }

        renderSimple(clone(descriptor));
      });
    }

    function openStepWizard(playlistId, kind) {
      openModal('Add to playlist', (container) => {
        const playlists = Object.keys(state.config.playlists);
        if (kind === 'screen') {
          const label = document.createElement('label');
          label.textContent = 'Screen';
          const picker = createScreenPicker(state.screens[0]);
          container.appendChild(label);
          container.appendChild(picker.element);
          modalHandler = () => {
            const selected = normaliseScreenId(picker.getValue());
            if (!selected) {
              alert('Select a screen from the list.');
              return false;
            }
            const playlist = state.config.playlists[playlistId];
            playlist.steps = playlist.steps || [];
            playlist.steps.push({ screen: selected });
            renderPlaylists();
            markDirty();
          };
        } else {
          const label = document.createElement('label');
          label.textContent = 'Playlist';
          const select = createOptionSelect(playlists.map(id => ({ value: id, label: id })), playlistId);
          container.appendChild(label);
          container.appendChild(select);
          modalHandler = () => {
            const playlist = state.config.playlists[playlistId];
            playlist.steps = playlist.steps || [];
            playlist.steps.push({ playlist: select.value });
            renderPlaylists();
            markDirty();
          };
        }
      });
    }

    function openRuleWizard(playlistId) {
      let ruleType = 'every';
      const containerBuilder = (container) => {
        const typeLabel = document.createElement('label');
        typeLabel.textContent = 'Rule type';
        const typeSelect = createOptionSelect([
          { value: 'every', label: 'Frequency (show every N loops)' },
          { value: 'cycle', label: 'Cycle (rotate through items)' },
          { value: 'variants', label: 'Variants (first available)' },
        ], ruleType);
        container.appendChild(typeLabel);
        container.appendChild(typeSelect);

        const formArea = document.createElement('div');
        container.appendChild(formArea);

        function renderForm() {
          formArea.innerHTML = '';
          ruleType = typeSelect.value;
          if (ruleType === 'every') {
            const freqLabel = document.createElement('label');
            freqLabel.textContent = 'Loop frequency';
            const freqControl = createFrequencyControl(3);

            const screenLabel = document.createElement('label');
            screenLabel.textContent = 'Screen to show at this frequency';
            const screenPicker = createScreenPicker(state.screens[0]);

            formArea.appendChild(freqLabel);
            formArea.appendChild(freqControl.element);
            formArea.appendChild(screenLabel);
            formArea.appendChild(screenPicker.element);

            modalHandler = () => {
              const freq = freqControl.getValue();
              if (!Number.isInteger(freq) || freq <= 0) {
                alert('Frequency must be a positive integer.');
                return false;
              }
              const selected = normaliseScreenId(screenPicker.getValue());
              if (!selected) {
                alert('Select a screen from the list.');
                return false;
              }
              const playlist = state.config.playlists[playlistId];
              playlist.steps = playlist.steps || [];
              playlist.steps.push({ rule: { type: 'every', frequency: freq, item: { screen: selected } } });
              renderPlaylists();
              markDirty();
            };
          } else if (ruleType === 'cycle') {
            const list = document.createElement('div');
            list.className = 'wizard-list';
            const items = [];

            function addRow(defaultType = 'screen', defaultValue = state.screens[0]) {
              const row = document.createElement('div');
              row.className = 'wizard-row';
              const typeSelect = createOptionSelect([
                { value: 'screen', label: 'Screen' },
                { value: 'playlist', label: 'Playlist' },
              ], defaultType);
              const valueSelect = document.createElement('select');
              function populateValue() {
                valueSelect.innerHTML = '';
                const options = typeSelect.value === 'screen' ? state.screens : Object.keys(state.config.playlists);
                options.forEach(opt => {
                  const option = document.createElement('option');
                  option.value = opt;
                  option.textContent = opt;
                  valueSelect.appendChild(option);
                });
                valueSelect.value = defaultValue;
              }
              populateValue();
              typeSelect.addEventListener('change', () => {
                defaultValue = typeSelect.value === 'screen' ? state.screens[0] : Object.keys(state.config.playlists)[0];
                populateValue();
              });
              const removeBtn = document.createElement('button');
              removeBtn.type = 'button';
              removeBtn.className = 'secondary';
              removeBtn.textContent = 'Remove';
              removeBtn.addEventListener('click', () => {
                const idx = items.indexOf(row);
                if (idx >= 0) {
                  items.splice(idx, 1);
                }
                row.remove();
              });
              row.appendChild(typeSelect);
              row.appendChild(valueSelect);
              row.appendChild(removeBtn);
              items.push(row);
              list.appendChild(row);
            }

            addRow();

            const addBtn = document.createElement('button');
            addBtn.type = 'button';
            addBtn.className = 'secondary';
            addBtn.textContent = 'Add item';
            addBtn.addEventListener('click', () => addRow());

            formArea.appendChild(list);
            formArea.appendChild(addBtn);

            modalHandler = () => {
              if (!items.length) {
                alert('Add at least one item to the cycle.');
                return false;
              }
              const descriptors = items.map(row => {
                const type = row.children[0].value;
                const value = row.children[1].value;
                return type === 'screen' ? { screen: value } : { playlist: value };
              });
              const playlist = state.config.playlists[playlistId];
              playlist.steps = playlist.steps || [];
              playlist.steps.push({ rule: { type: 'cycle', items: descriptors } });
              renderPlaylists();
              markDirty();
            };
          } else {
            const list = document.createElement('div');
            list.className = 'wizard-list';
            const items = [];

            function addVariant(defaultValue = state.screens[0]) {
              const row = document.createElement('div');
              row.className = 'wizard-row';
              row.style.gridTemplateColumns = '1fr auto';
              const select = createOptionSelect(state.screens.map(id => ({ value: id, label: id })), defaultValue);
              const removeBtn = document.createElement('button');
              removeBtn.type = 'button';
              removeBtn.className = 'secondary';
              removeBtn.textContent = 'Remove';
              removeBtn.addEventListener('click', () => {
                const idx = items.indexOf(row);
                if (idx >= 0) {
                  items.splice(idx, 1);
                }
                row.remove();
              });
              row.appendChild(select);
              row.appendChild(removeBtn);
              items.push(row);
              list.appendChild(row);
            }

            addVariant();
            const addBtn = document.createElement('button');
            addBtn.type = 'button';
            addBtn.className = 'secondary';
            addBtn.textContent = 'Add variant';
            addBtn.addEventListener('click', () => addVariant());

            formArea.appendChild(list);
            formArea.appendChild(addBtn);

            modalHandler = () => {
              const options = items.map(row => row.children[0].value).filter(Boolean);
              if (!options.length) {
                alert('Add at least one variant.');
                return false;
              }
              const playlist = state.config.playlists[playlistId];
              playlist.steps = playlist.steps || [];
              playlist.steps.push({ rule: { type: 'variants', options } });
              renderPlaylists();
              markDirty();
            };
          }
        }

        typeSelect.addEventListener('change', renderForm);
        renderForm();
      };

      openModal('Rule wizard', containerBuilder);
    }

    function openConditionEditor(playlistId) {
      const playlist = state.config.playlists[playlistId];
      const conditions = clone(playlist.conditions || {});
      const selectedDays = new Set((conditions.days_of_week || conditions.day_of_week || []).map(day => day.toLowerCase()));
      const ranges = Array.isArray(conditions.time_of_day) ? conditions.time_of_day.slice() : [];

      openModal('Conditions', (container) => {
        const dayLabel = document.createElement('label');
        dayLabel.textContent = 'Days of week';
        const dayGrid = document.createElement('div');
        dayGrid.className = 'day-grid';
        const days = ['mon','tue','wed','thu','fri','sat','sun'];
        days.forEach(day => {
          const chip = document.createElement('label');
          chip.className = 'day-chip' + (selectedDays.has(day) ? ' selected' : '');
          const input = document.createElement('input');
          input.type = 'checkbox';
          input.checked = selectedDays.has(day);
          input.addEventListener('change', () => {
            if (input.checked) selectedDays.add(day); else selectedDays.delete(day);
            chip.classList.toggle('selected', input.checked);
          });
          const span = document.createElement('span');
          span.textContent = day.toUpperCase();
          chip.appendChild(input);
          chip.appendChild(span);
          dayGrid.appendChild(chip);
        });

        const rangeLabel = document.createElement('label');
        rangeLabel.textContent = 'Time of day ranges (HH:MM)';
        const rangeList = document.createElement('div');
        rangeList.className = 'wizard-list';

        function renderRanges() {
          rangeList.innerHTML = '';
          ranges.forEach((rng, idx) => {
            const row = document.createElement('div');
            row.className = 'wizard-row';
            const start = document.createElement('input');
            start.type = 'time';
            start.value = rng.start || '';
            start.addEventListener('change', () => rng.start = start.value);
            const end = document.createElement('input');
            end.type = 'time';
            end.value = rng.end || '';
            end.addEventListener('change', () => rng.end = end.value);
            const remove = document.createElement('button');
            remove.type = 'button';
            remove.className = 'secondary';
            remove.textContent = 'Remove';
            remove.addEventListener('click', () => {
              ranges.splice(idx, 1);
              renderRanges();
            });
            row.appendChild(start);
            row.appendChild(end);
            row.appendChild(remove);
            rangeList.appendChild(row);
          });
        }

        renderRanges();
        const addRange = document.createElement('button');
        addRange.type = 'button';
        addRange.className = 'secondary';
        addRange.textContent = 'Add range';
        addRange.addEventListener('click', () => {
          ranges.push({ start: '08:00', end: '18:00' });
          renderRanges();
        });

        container.appendChild(dayLabel);
        container.appendChild(dayGrid);
        container.appendChild(rangeLabel);
        container.appendChild(rangeList);
        container.appendChild(addRange);

        modalHandler = () => {
          const output = {};
          if (selectedDays.size) {
            output.days_of_week = Array.from(selectedDays);
          }
          const cleanedRanges = ranges.filter(r => r.start && r.end);
          if (cleanedRanges.length) {
            output.time_of_day = cleanedRanges;
          }
          playlist.conditions = Object.keys(output).length ? output : undefined;
          renderPlaylists();
          markDirty();
        };
      });
    }

    function openStepEditor(playlistId, index) {
      const playlist = state.config.playlists[playlistId];
      const step = clone(playlist.steps[index]);
      openDescriptorEditor('Edit step', step, (updated) => {
        playlist.steps[index] = updated;
        renderPlaylists();
        markDirty();
      });
    }

    function openSequenceEditor(index) {
      const step = clone(state.config.sequence[index]);
      openDescriptorEditor('Edit sequence entry', step, (updated) => {
        state.config.sequence[index] = updated;
        renderSequence();
        markDirty();
      });
    }

    function addPlaylistToSequence() {
      const ids = Object.keys(state.config.playlists);
      if (!ids.length) return;
      openModal('Insert playlist', (container) => {
        const select = createOptionSelect(ids.map(id => ({ value: id, label: id })), ids[0]);
        container.appendChild(select);
        modalHandler = () => {
          state.config.sequence.push({ playlist: select.value });
          renderSequence();
          markDirty();
        };
      });
    }

    function addScreenToSequence() {
      openModal('Insert screen', (container) => {
        const picker = createScreenPicker(state.screens[0]);
        container.appendChild(picker.element);
        modalHandler = () => {
          const selected = normaliseScreenId(picker.getValue());
          if (!selected) {
            alert('Select a screen from the list.');
            return false;
          }
          state.config.sequence.push({ screen: selected });
          renderSequence();
          markDirty();
        };
      });
    }

    function createPlaylist() {
      let counter = Object.keys(state.config.playlists).length + 1;
      let id;
      do {
        id = `playlist_${counter++}`;
      } while (state.config.playlists[id]);
      state.config.playlists[id] = { label: `Playlist ${counter}`, steps: [] };
      state.config.sequence.push({ playlist: id });
      renderAll();
      markDirty();
    }

    async function saveConfig() {
      state.saving = true;
      state.statusMessage = null;
      renderStatus();
      try {
        const response = await fetch('/save_config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ config: state.config, actor: actorInput.value || undefined, summary: summaryInput.value || undefined }),
        });
        const payload = await response.json();
        if (!response.ok || payload.status !== 'success') {
          throw new Error(payload.message || 'Save failed');
        }
        state.config = payload.config;
        state.validation = payload.validation || [];
        state.versions = payload.versions || [];
        state.latestVersionId = payload.latest_version_id;
        state.migrated = payload.migrated;
        state.dirty = false;
        state.statusMessage = { text: `Saved as version #${payload.version_id}`, error: false };
        renderAll();
      } catch (err) {
        state.statusMessage = { text: `Save failed: ${err.message}`, error: true };
      } finally {
        state.saving = false;
        renderStatus();
      }
    }

    async function runPreview() {
      try {
        state.statusMessage = { text: 'Generating preview…', error: false };
        const response = await fetch('/preview', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ config: state.config, count: 20 }),
        });
        const payload = await response.json();
        if (!response.ok || payload.status !== 'ok') {
          throw new Error(payload.message || 'Preview failed');
        }
        state.preview = payload.preview || [];
        state.previewOpen = true;
        renderPreview();
        state.statusMessage = { text: 'Preview generated', error: false };
        renderStatus();
      } catch (err) {
        state.statusMessage = { text: `Preview failed: ${err.message}`, error: true };
        renderStatus();
      }
    }
 
    async function rollbackVersion(versionId) {
      if (!confirm(`Restore configuration version #${versionId}?`)) {
        return;
      }
      try {
        state.statusMessage = { text: `Restoring version #${versionId}…`, error: false };
        const response = await fetch('/config/rollback', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ version_id: versionId, actor: actorInput.value || undefined }),
        });
         const payload = await response.json();
         if (!response.ok || payload.status !== 'success') {
           throw new Error(payload.message || 'Rollback failed');
         }
         state.config = payload.config;
         state.validation = payload.validation || [];
        state.versions = payload.versions || [];
        state.latestVersionId = payload.latest_version_id;
        state.migrated = payload.migrated;
        state.dirty = false;
        state.statusMessage = { text: `Restored version #${versionId}`, error: false };
        renderAll();
      } catch (err) {
        state.statusMessage = { text: `Rollback failed: ${err.message}`, error: true };
        renderStatus();
      }
    }
 
     document.getElementById('save-button').addEventListener('click', saveConfig);
     document.getElementById('preview-button').addEventListener('click', () => {
       runPreview();
     });
     document.getElementById('close-preview').addEventListener('click', () => {
       state.previewOpen = false;
       renderPreview();
     });
     document.getElementById('new-playlist').addEventListener('click', createPlaylist);
     document.getElementById('add-sequence-playlist').addEventListener('click', addPlaylistToSequence);
     document.getElementById('add-sequence-screen').addEventListener('click', addScreenToSequence);
 
     renderAll();
   </script>
 </body>
 </html>
